/// Implementation of the DfgToDpmWrappers pass.
///
/// @file
/// @author     Fabius Mayer-Uhma (fabius.mayer-uhma@tu-dresden.de)

#include "dfg-mlir/Conversion/DfgToDpmWrappers/DfgToDpmWrappers.h"

#include "dfg-mlir/Dialect/dfg/IR/Dialect.h"
#include "dfg-mlir/Dialect/dfg/IR/Ops.h"
#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
#include "mlir/Conversion/LLVMCommon/Pattern.h"
#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
#include "mlir/Dialect/ControlFlow/IR/ControlFlow.h"
#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/Func/Transforms/FuncConversions.h"
#include "mlir/Dialect/LLVMIR/FunctionCallUtils.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
#include "mlir/IR/BuiltinDialect.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/Dialect/EmitC/IR/EmitC.h"

namespace mlir {
#define GEN_PASS_DEF_CONVERTDFGTODPMWRAPPERS
#include "dfg-mlir/Conversion/Passes.h.inc"
} // namespace mlir

using namespace mlir;
using namespace mlir::dfg;

// ========================================================
// Lowerings
// ========================================================

// IMPORTANT: THIS HAS TO BE IN AN UNIQUE NAMESPACE!! IF NOT YOUR CONVERSION
// PATTERNS MIGHT BE NAMED LIKE AN ALREADY EXISTING ONE WHICH LEADS TO
// UNTRACABLE ERRORS
namespace {

struct ConvertDfgToDpmWrappersPass : public mlir::impl::ConvertDfgToDpmWrappersBase<
                                      ConvertDfgToDpmWrappersPass> {
    void runOnOperation() final;
};


std::vector<emitc::FuncOp> collectedFunctions;

struct PushOpLowering : public mlir::OpConversionPattern<PushOp> {
    using OpConversionPattern<PushOp>::OpConversionPattern;

    PushOpLowering(TypeConverter &typeConverter, MLIRContext* context)
            : OpConversionPattern<PushOp>(typeConverter, context) {};

    LogicalResult matchAndRewrite(
        PushOp pushOp,
        PushOpAdaptor adaptor,
        ConversionPatternRewriter &rewriter) const override
    {

        rewriter.eraseOp(pushOp);
        return success();
    }
};

struct PullOpLowering : public mlir::OpConversionPattern<PullOp> {
    using OpConversionPattern<PullOp>::OpConversionPattern;

    PullOpLowering(TypeConverter &typeConverter, MLIRContext* context)
            : OpConversionPattern<PullOp>(typeConverter, context) {};

    LogicalResult matchAndRewrite(
        PullOp pullOp,
        PullOpAdaptor adaptor,
        ConversionPatternRewriter &rewriter) const override
    {

        rewriter.eraseOp(pullOp);
        return success();
    }
};

struct ChannelOpLowering : public mlir::OpConversionPattern<ChannelOp> {
    using OpConversionPattern<ChannelOp>::OpConversionPattern;

    ChannelOpLowering(TypeConverter &typeConverter, MLIRContext* context)
            : OpConversionPattern<ChannelOp>(typeConverter, context) {};

    LogicalResult matchAndRewrite(
        ChannelOp channelOp,
        ChannelOpAdaptor adaptor,
        ConversionPatternRewriter &rewriter) const override
    {

        rewriter.eraseOp(channelOp);
        return success();
    }
};


struct ProcessOpLowering : public mlir::OpConversionPattern<ProcessOp> {
    using OpConversionPattern<ProcessOp>::OpConversionPattern;

    ProcessOpLowering(TypeConverter &typeConverter, MLIRContext* context)
            : OpConversionPattern<ProcessOp>(typeConverter, context) {};

    LogicalResult matchAndRewrite(
        ProcessOp processOp,
        ProcessOpAdaptor adaptor,
        ConversionPatternRewriter &rewriter) const override
    {

        rewriter.eraseOp(processOp);
        return success();
    }
};



struct InstantiateOpLowering : public mlir::OpConversionPattern<InstantiateOp> {
    using OpConversionPattern<InstantiateOp>::OpConversionPattern;

    InstantiateOpLowering(TypeConverter &typeConverter, MLIRContext* context)
            : OpConversionPattern<InstantiateOp>(typeConverter, context) {};

    LogicalResult matchAndRewrite(
        InstantiateOp instantiateOp,
        InstantiateOpAdaptor adaptor,
        ConversionPatternRewriter &rewriter) const override
    {

aa        rewriter.eraseOp(instantiateOp);
        return success();
    }
};


void ConvertDfgToDpmWrappersPass::runOnOperation()
{
    Operation* op = getOperation();

    ModuleOp globalModuleOp;
    op->walk([&globalModuleOp](ModuleOp moduleOp){
        globalModuleOp = moduleOp;
        return WalkResult::interrupt();
    });

    TypeConverter typeConverter;

    OpBuilder rewriter(&getContext());

    ConversionTarget target(getContext());
    RewritePatternSet patterns(&getContext());

    typeConverter.addConversion([](Type t){return t;});

    patterns.add<InstantiateOpLowering, ProcessOpLowering, ChannelOpLowering, PushOpLowering, PullOpLowering>(typeConverter, patterns.getContext());

    target.addLegalDialect<emitc::EmitCDialect>();
    target.addIllegalDialect<DfgDialect>();

    // use PartialConversion because error logs are better
    if (failed(applyPartialConversion(op, target, std::move(patterns))))
        signalPassFailure();

    // erase everything but the global module
    op->walk([&op](Operation* operation){
        if(operation != op)
            operation->erase();
    });

    rewriter.setInsertionPointToStart(globalModuleOp.getBody());
    for(emitc::FuncOp funcOp : collectedFunctions){
        rewriter.insert(funcOp);
    }

}

} // namespace

std::unique_ptr<Pass> mlir::createConvertDfgToDpmWrappersPass()
{
    return std::make_unique<ConvertDfgToDpmWrappersPass>();
}
